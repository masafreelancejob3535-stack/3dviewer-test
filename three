<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3Dモデル簡易ビューア（Three.js版）</title>
  <style>
    :root { --bg:#0f1216; --fg:#e8eef6; --muted:#9fb0c6; --border:#263140; --card:#151a21; --accent:#7cc; }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.6 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;display:flex;flex-direction:column}
    header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;background:linear-gradient(180deg, #121820, #0f1216);position:sticky;top:0;z-index:2}
    h1{margin:0;font-size:16px;font-weight:600;letter-spacing:.3px}
    .pill{display:inline-block;padding:4px 8px;border:1px solid var(--border);border-radius:999px;color:var(--muted);font-size:12px}
    .spacer{flex:1}
    main{display:grid;grid-template-columns:1fr 320px;gap:0;min-height:0;flex:1}
    @media (max-width: 980px){ main{grid-template-columns:1fr} aside{order:-1;border-right:none;border-bottom:1px solid var(--border)} }
    #stage{position:relative;min-height: calc(100vh - 56px)}
    canvas{display:block;width:100%;height:100%}
    .drop{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;opacity:0;transition:.2s}
    .drop.show{opacity:1;background:#0007;backdrop-filter: blur(3px)}
    .drop .box{border:2px dashed #7cc;border-radius:16px;padding:24px 28px;background:#111a; color:#cff; font-weight:600}
    aside{border-left:1px solid var(--border);padding:14px;background:linear-gradient(180deg, #0f1216, #0f141a);}
    .group{border:1px solid var(--border);border-radius:12px;background:var(--card);padding:12px;margin-bottom:12px}
    .group h2{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:600}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0;flex-wrap:wrap}
    label{font-size:13px;color:var(--muted)}
    input[type="file"], input[type="text"]{width:100%}
    .btn{appearance:none;border:1px solid var(--border);background:#0d141b;color:var(--fg);padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;font-size:13px}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:#0b1015;color:#cfe}
    .hint{font-size:12px;color:var(--muted)}
    footer{padding:10px 16px;border-top:1px solid var(--border);color:var(--muted);font-size:12px;text-align:center}
    a{color:var(--accent);text-decoration:none}
  </style>
</head>
<body>
  <header>
    <h1>3Dモデル簡易ビューア</h1>
    <span class="pill">Three.js</span>
    <span class="spacer"></span>
    <a class="hint" href="index.html">← model-viewer 版へ</a>
  </header>

  <main>
    <section id="stage">
      <div id="drop" class="drop"><div class="box">ここに .glb / .gltf をドロップ</div></div>
    </section>

    <aside>
      <div class="group">
        <h2>モデルを読み込む</h2>
        <div class="row">
          <input id="file" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json"/>
        </div>
        <div class="row">
          <input id="url" type="text" placeholder="モデルのURL（https:// 〜 .glb）" />
          <button id="loadUrl" class="btn">読込</button>
        </div>
        <p class="hint">ドラッグ＆ドロップも可能。クエリ <code>?src=...</code> でも自動読込します。</p>
      </div>

      <div class="group">
        <h2>表示設定</h2>
        <div class="row">
          <button id="reset" class="btn">カメラリセット</button>
          <button id="frame" class="btn secondary">モデルにフレーム</button>
        </div>
        <div class="row">
          <label for="env">環境光：</label>
          <input id="env" type="range" min="0" max="2" step="0.05" value="0.8"/>
          <span id="envVal" class="hint">0.8</span>
        </div>
        <div class="row">
          <label for="dir">平行光：</label>
          <input id="dir" type="range" min="0" max="2" step="0.05" value="1.0"/>
          <span id="dirVal" class="hint">1.0</span>
        </div>
      </div>

      <div class="group">
        <h2>ヒント</h2>
        <ul class="hint">
          <li>クリック＆ドラッグで回転、ホイールでズーム、右ドラッグでパン（OrbitControls）。</li>
          <li>読み込んだモデルは影を落とします（cast/receiveShadow）。床シャドウはソフト。</li>
        </ul>
      </div>
    </aside>
  </main>

  <footer>
    © 2025 Simple GLB Viewer. / 技術: Three.js
  </footer>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    const stage = document.getElementById('stage');
    const file = document.getElementById('file');
    const url = document.getElementById('url');
    const loadUrlBtn = document.getElementById('loadUrl');
    const resetBtn = document.getElementById('reset');
    const frameBtn = document.getElementById('frame');
    const env = document.getElementById('env');
    const dir = document.getElementById('dir');
    const envVal = document.getElementById('envVal');
    const dirVal = document.getElementById('dirVal');
    const drop = document.getElementById('drop');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x12161b);

    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 2000);
    camera.position.set(0, 1.5, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.shadowMap.enabled = true;
    renderer.setPixelRatio(devicePixelRatio);
    stage.appendChild(renderer.domElement);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x202030, parseFloat(env.value));
    scene.add(hemi);

    const dirLight = new THREE.DirectionalLight(0xffffff, parseFloat(dir.value));
    dirLight.position.set(5,10,7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    // Ground with soft shadow
    const groundGeo = new THREE.PlaneGeometry(50,50);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 0.2;
    controls.maxDistance = 20;

    // Resize
    function onResize(){
      const rect = stage.getBoundingClientRect();
      const w = rect.width;
      const h = Math.max(240, window.innerHeight - 56); // header height approx
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // Model loading
    const loader = new GLTFLoader();
    let current, currentBox;

    function clearModel(){
      if (current) {
        scene.remove(current);
        current.traverse(o => {
          if (o.isMesh) { o.geometry.dispose(); if (o.material?.dispose) o.material.dispose(); }
        });
        current = null;
        currentBox = null;
      }
    }

    async function loadFromURL(src){
      clearModel();
      loader.load(src, (gltf) => {
        current = gltf.scene;
        current.traverse(n => { if (n.isMesh){ n.castShadow = true; n.receiveShadow = true; n.material.side = THREE.FrontSide; }});
        scene.add(current);
        frameToModel();
      }, undefined, (err) => {
        console.error(err);
        alert('読み込みに失敗しました: ' + err.message);
      });
    }

    function frameToModel(){
      // Compute bounding box
      const box = new THREE.Box3().setFromObject(current);
      currentBox = box;
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      // Move model to origin (optional visual centering)
      current.position.x += (current.position.x - center.x);
      current.position.y += (current.position.y - center.y);
      current.position.z += (current.position.z - center.z);

      // Fit camera to object
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let camZ = Math.abs(maxDim / Math.sin(fov/2)) * 0.7;
      camZ = THREE.MathUtils.clamp(camZ, 1.2, 100);
      camera.position.set(center.x + camZ*0.25, center.y + camZ*0.25, center.z + camZ);
      controls.target.copy(center);
      controls.update();
      ground.position.y = box.min.y - 0.001;
    }

    // File input
    file.addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const objectURL = URL.createObjectURL(f);
      loadFromURL(objectURL);
    });

    // URL input
    loadUrlBtn.addEventListener('click', () => {
      const u = url.value.trim();
      if (u) loadFromURL(u);
    });

    // Query param
    const params = new URLSearchParams(location.search);
    const initialSrc = params.get('src');
    if (initialSrc) {
      url.value = initialSrc;
      loadFromURL(initialSrc);
    }

    // Drag & drop
    const prevent = e => { e.preventDefault(); e.stopPropagation(); }
    ;['dragenter','dragover','dragleave','drop'].forEach(ev => {
      stage.addEventListener(ev, prevent, false);
    });
    ;['dragenter','dragover'].forEach(ev => {
      stage.addEventListener(ev, () => drop.classList.add('show'), false);
    });
    ;['dragleave','drop'].forEach(ev => {
      stage.addEventListener(ev, () => drop.classList.remove('show'), false);
    });
    stage.addEventListener('drop', (e) => {
      const f = e.dataTransfer?.files?.[0];
      if (f && (f.name.endsWith('.glb') || f.name.endsWith('.gltf'))) {
        const objectURL = URL.createObjectURL(f);
        loadFromURL(objectURL);
      }
    });

    // UI
    resetBtn.addEventListener('click', () => {
      controls.reset();
    });
    frameBtn.addEventListener('click', () => {
      if (current) frameToModel();
    });
    env.addEventListener('input', () => {
      hemi.intensity = parseFloat(env.value);
      envVal.textContent = env.value;
    });
    dir.addEventListener('input', () => {
      dirLight.intensity = parseFloat(dir.value);
      dirVal.textContent = dir.value;
    });

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
